

solidity:写智能合约,包含token合约

发币:通过多种方式去发布代币到私有链,以太坊测试链,以太坊主链.

钱包开发:功能主要是账户操作,转账交易,交易查询.

交易所开发:功能主要是账户系统,提现,充值,挂单,币转币

----------大部分主要是中心化的交易所...----------------

提现充值就是走链上  web3

每一个币就是一个智能合约,每一个智能合约就是拥有一个账本

token合约只是智能合约的一种,通过智能合约可以实现众筹,投票,物联网,溯源等等应用场景.

交易所开发也会用到token合约,token合约只是只能合约的一部分价值实现的代表.

市场上常见的代币都是基于以太坊发布的代币.

智能合约是运行在以太坊虚拟机环境当中,(evm),智能合约的发布,部署都是需要花费gas的,所以要先在测试网络,私有网络虚拟机测试,直接分布在主链上需要的成本较高.最后在部署在主网上面.

solidity在编译完成之后会生成abi(应用程序二进制接口文件)和字节码文件

solidity当中,编写智能合约时:

delegatecall 和 call的区别:call改变的是被调用合约的状态发生变化,delegatecall改变的是调用者本身的状态发生变化.

构造函数在合约对象创建时,会首先调用构造函数对相关数据进行初始化操作处理,只会在合约部署时调用一次
成员函数

析构函数和构造函数:

构造函数是初始化数据,而析构函数是销毁数据.在contract合约中,当我们手动调用kill函数时,就会调用selfdestruct销毁当前的合约.

匿名方法:

一个合约可以有匿名函数,此函数不能有参数,也不能有任何返回值,当我们企图取执行一个合约上没有的方法时,那么合约就执行匿名函数.

此外,当合约收到以太币的时候,也回去调用这个匿名函数,一般情况下只会消耗很设哦的gas,所以当得到以太币的时候,逍遥执行一些操作,尽可能的把你要写的操作写在匿名函数里面,因为这样成本很低.

区块链默认只是向区块链读取数据不需要消耗gas,但是不消耗gas就修改不了数据,写入数据或者修改状态变量的值时都需要花费gas.

memory,storage:

memory:值类型(深拷贝)

storage:引用类型(浅拷贝)

值类型的数据只能通过深拷贝(memory)取传递数据,引用类型可以通过数值和引用(memory,storage)两种形式传似数据

transfer是用于转账,是调用合约的地址,向owner进行转账

合约部署完成以后,合约本身也是有地址的,this代表当前合约,地址代表的就是合约本身,合约对象也会自动继承地址的对象,包含地址的属性方法.

向合约进行转账,要用send,用transfer进行转账会进行报错......

solidity语言当中: 2**3 =8  代表立方的数学运算

固定长度的字节数组,内容不能进行修改,他是值类型,只能获取其内容和长度....

函数参数的默认是memory值拷贝,如果引用类型向进行浅拷贝的话,函数参数传递的时候进行storage修饰.

一个字符就是一个字节的长度

solidity:

1.函数名称中的返回,需要使用returns,但函数体里面用的还是return .每行代码必须加上分号.